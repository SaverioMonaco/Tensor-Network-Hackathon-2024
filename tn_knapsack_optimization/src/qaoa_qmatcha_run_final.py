# -*- coding: utf-8 -*-
"""QAOA_qmatcha_run_latest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bEhkaMajkOCl4L-Nn-Nhq3G4voxxCMlq
"""


from qiskit.circuit.library import TwoLocal, RZZGate, SwapGate
from qiskit.circuit import ParameterVector
import numpy as np
from scipy.optimize import minimize
import qtealeaves.observables as obs
from qmatchatea import QCOperators, run_simulation, QCConvergenceParameters
from qiskit import QuantumCircuit
import qubo
import ising
import data

def qaoa_step(theta, ansatz, observables, conv_params=None):
    ops = QCOperators()
    ops.ops["Z"] = np.array([[1, 0], [0, -1]])
    # bind the parametric ansatz to the parameters
    binded_ansatz = ansatz.assign_parameters(theta)
    # Run the simulation
    res = run_simulation(binded_ansatz, observables=observables, convergence_parameters=conv_params, operators=ops)

    # for key, value in res.measures.items():
    #     print(f"{key} : {value}")
    
    bitstring = max(res.measures, key= lambda x: res.measures[x])
    print(bitstring)

    return np.real(res.observables["hamiltonian"])

def qaoa_all(Q, h, J, reps=2):
    num_qubits = np.shape(Q)[0]
    qc = QuantumCircuit(num_qubits)

    theta = ParameterVector('Î¸', 2 * reps)

    for ii in range(num_qubits):
        qc.h(ii)
    for r in range(reps):
        for ii in range(num_qubits):
            qc.rz(2 * theta[2 * r] * h[ii], ii)

        for ii in range(num_qubits):
            for jj in range(ii):
                for kk in range(jj, ii-1):
                    qc.swap(kk, kk+1)
                qc.rzz(2 * theta[2 * r] * J[(ii-1,ii)], ii-1, ii)
                for kk in reversed(range(jj+1, ii)):
                    qc.swap(kk, kk-1)
                #qc.rzz(2 * theta[2 * r] * J[(jj,ii)], jj, ii)

        for ii in range(num_qubits):
            qc.rx(2 * theta[2 * r + 1], ii)

    return qc

def operators(Q, h, J):
    num_qubits = np.shape(Q)[0]
    local = [
            {
                "label": "I" * ii + "Z" + "I" * (num_qubits - ii - 1),
                "coeff": {"real": h[ii], "imag": 0},
            }
            for ii in range(num_qubits)
        ]

    two_body=[]
    for (i, j), J_ij in J.items():
          #print(i,j)
          two_body.append(
          {
              "label": "I" * i + "Z" + "I" * (j - i - 1) + "Z" + "I" * (num_qubits - j - 1),
              "coeff": {"real": J_ij, "imag": 0},
          }
      )
    #print(len(local))
    #print(len(two_body), len(J.items()))
    pauli_dict_hamiltonian = {"paulis": local + two_body}

    return pauli_dict_hamiltonian

def main():
    problems=data.load("small", "../kp_instances")
    problem=problems[0]
    qubo1=qubo.get_Q(problem['weights'], problem['profits'], problem['C'], max(problem['profits'])*1.1)
    h, J, Cte=ising.qubo_to_hamiltonian(qubo1)
    #H = ising.construct_quantum_hamiltonian_qiskit(h, J, Cte)
    pauli_dict_hamiltonian = operators(qubo1, h, J)
    obsv = obs.TNObservables()
    ham = obs.TNObsWeightedSum.from_pauli_string("hamiltonian", pauli_dict_hamiltonian)
    obsv += ham
    
    num_shots = 1024
    obsv += obs.TNObsProjective(num_shots)
    obsv += obs.TNState2File("state.txt", "F")

    conv_params = QCConvergenceParameters(max_bond_dimension=100)
    reps = 10
    qc=qaoa_all(qubo1, h, J, reps)
    qaoa_step_opt = lambda x: qaoa_step(x, qc, obsv, conv_params)
    np.random.seed(42)
    initial_guess = np.random.normal(np.pi / 2, 0.05, qc.num_parameters)
    initial_energy = qaoa_step_opt(initial_guess)
    print(f"Initial energy: {initial_energy}")

    res = minimize(qaoa_step_opt, initial_guess, method="COBYLA")

    final_energy = qaoa_step_opt(res.x)
    print(f"Final energy: {final_energy} constant: {Cte}")
    print(f"Reps: {reps}")
#print(qubo1.shape)


if __name__ == "__main__":
    main()

