# -*- coding: utf-8 -*-
"""QAOA_qmatcha_run_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bEhkaMajkOCl4L-Nn-Nhq3G4voxxCMlq
"""

#!pip install qiskit==0.45.0

#!pip install qiskit_algorithms

#pip install -U qiskit-aer
#!pip uninstall qmatchatea

from qiskit.circuit.library import TwoLocal, RZZGate, SwapGate
from qiskit.circuit import ParameterVector
import numpy as np
from scipy.optimize import minimize
import qtealeaves.observables as obs
from qmatchatea import QCOperators, run_simulation, QCConvergenceParameters
from qiskit import QuantumCircuit
import qubo
import ising
import data

def qaoa_step(theta, ansatz, observables, conv_params):
    ops = QCOperators()
    ops.ops["Z"] = np.array([[1, 0], [0, -1]])
    # bind the parametric ansatz to the parameters
    binded_ansatz = ansatz.assign_parameters(theta)
    # Run the simulation
    res = run_simulation(binded_ansatz, convergence_parameters=conv_params, observables=observables, operators=ops)

    for key, value in res.measures.items():
        print(f"{key} : {value}")

    bitstring = max(res.measures, key= lambda x: res.measures[x])
    print(bitstring)

    return np.real(res.observables["hamiltonian"])

def qaoa_all(Q, h, J, reps=2):
    num_qubits = np.shape(Q)[0]
    qc = QuantumCircuit(num_qubits)

    theta = ParameterVector('Î¸', 2 * reps)

    for ii in range(num_qubits):
        qc.h(ii)
    for r in range(reps):
        for ii in range(num_qubits):
            qc.rz(2 * theta[2 * r] * h(ii), ii)

        for ii in range(num_qubits):
            for jj in range(ii):
              for kk in range(jj, ii-1):
                qc.swap(kk, kk+1)
              qc.rzz(2 * theta[2 * r] * J[(ii-1,ii)], ii-1, ii)
              for kk in reversed(range(jj, ii - 1)):
                qc.swap(kk, kk-1)

        for ii in range(num_qubits):
            qc.rx(2 * theta[2 * r + 1], ii)

    return qc

def operators(Q, h, J):
    num_qubits = np.shape(Q)[0]
    local = [
            {
                "label": "I" * ii + "Z" + "I" * (num_qubits - ii - 1),
                "coeff": {"real": h[ii], "imag": 0},
            }
            for ii in range(num_qubits)
        ]


    for (i, j), J_ij in J.items():
          two_body = [
          {
              "label": "I" * i + "Z" + "I" * (j - i - 1) + "Z" + "I" * (num_qubits - j - 1),
              "coeff": {"real": J_ij, "imag": 0},
          }
      ]

    pauli_dict_hamiltonian = {"paulis": local + two_body}

    return pauli_dict_hamiltonian

def main():
    problems=data.load("small", "./../kp_instances")
    problem=problems[0]
    qubo1=qubo.get_Q(problem['weights'], problem['profits'], problem['C'], 10)
    h, J, Cte=ising.qubo_to_hamiltonian(qubo1)
    H = ising.construct_quantum_hamiltonian_qiskit(h, J, Cte)
    pauli_dict_hamiltonian = operators(qubo1, h, J)
    obsv = obs.TNObservables()
    ham = obs.TNObsWeightedSum.from_pauli_string("hamiltonian", pauli_dict_hamiltonian)
    obsv += ham

    num_shots = 1024
    obsv += obs.TNObsProjective(num_shots)
    obsv += obs.TNState2File("state.txt", "F")

    conv_params = QCConvergenceParameters(max_bond_dimension=10)

    reps = 3
    qc = qaoa_all(Q, h, J, reps)
    qaoa_step_opt = lambda x: qaoa_step(x, qc, obsv, conv_params)
    initial_guess = np.random.normal(np.pi / 2, 0.05, qc.num_parameters)
    initial_energy = qaoa_step_opt(initial_guess)
    print(f"Initial energy: {initial_energy}")

    res = minimize(qaoa_step_opt, initial_guess, method="COBYLA")

    final_energy = qaoa_step_opt(res.x)
    print(f"Final energy: {final_energy}")



#print(qubo1.shape)

main()

